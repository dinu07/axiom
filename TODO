 - axiom-core
  - remove the bean id lookup indirection: it is pointless 
  - hook up the bootstrap
  - deal with route/rule specifications coming in off the wire
   - write xlst for xml2code
    - think about whether transformations should go the other way!?
  - think about whether route/rule data should be transient or persistent
   - discover whether (or not) camel route related objects can easily be accessed and/or serialized
    - if they are (both easy to access/find in the runtime object graph
     - if they can be serialized without much hassle - we should put this in for completeness
     - otherwise it is a prioritization that doesn' need to take place in the first few weeks of Beta.
 - axiom-server
   - add an 'axiom-server' child project and in it:
   - create a default entry point so the jar is executable
   - wire the main method with commons-cli so that argument handling is well tested
   - have the main method work out the args and start a ControlChannel using a BootstrapRouteLoader
   - write an axiom mojo so you can run `mvn axiom:deploy axiom:run`
 - add an 'axiom-client' project
   - decide on how
    - a jar and Main.java that just wrap around a jruby script is probably the most consistent approach
   - just talk to the server using http
   - convert commands into either camel objects for serialization, or by hand
 - misc
  - move direct junit4 dependencies out of the poms
  - get either the cobertura or emma plugins working (they currently seem to break the build)
 * - general switch from commons-logging to slf4j (API)
   - implementations might use logback, as this looks preferable to log4j
  - get maven-assembly-plugin set up to create a proper (usable) bundle of jars and scripts
  - set up profiles so you can build and package (for distribution) individual components
  - find somewhere to host binaries for downloading, perhaps sourceforge. 
  - get maven build generating javadoc
  - start writing some documentation on github/wiki
  - set up an axiom blog
